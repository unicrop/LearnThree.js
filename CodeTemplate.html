<!DOCTYPE html>
<html lang="en">
<head>
    <title>Code Template</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>

<div id="container"></div>
<script type="text/javascript" src="js/three.min.js"></script>
<script type="text/javascript" src="js/OrbitControls.js"></script>
<script type="text/javascript" src="js/OBJLoader.js"></script>
<script type="text/javascript" src="js/MTLLoader.js"></script>
<script type="module">

    /*******
     * 初始化渲染器：initRender
     * 初始化相机：initCamera
     * 初始化场景：initScene
     * 初始化灯源：initLight
     * 初始化模型：initModel
     * 初始化控制器：initControls
     * 动画：animate
     * 绘制：draw
    *******/
    var renderer, container, camera, scene, light;
    init();
    animate();

    function initRender() {
        container = document.getElementById("container");
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        //告诉渲染器需要阴影效果
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
        container.appendChild(renderer.domElement);
    }

    function initCamera() {
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000 );
        camera.position.set(5000, 5000, 5000);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
    }

    function initScene() {
        //cubemap
        var path = 'textures/cube/skybox/';
        var format = '.jpg';
        var urls = [
            path + 'px' + format, path + 'nx' + format,
            path + 'py' + format, path + 'ny' + format,
            path + 'pz' + format, path + 'nz' + format
        ];

        var reflectionCube = new THREE.CubeTextureLoader().load( urls );
        reflectionCube.format = THREE.RGBFormat;

        var refractionCube = new THREE.CubeTextureLoader().load( urls );
        refractionCube.mapping = THREE.CubeRefractionMapping;
        refractionCube.format = THREE.RGBFormat;
        scene = new THREE.Scene();
        scene.background = reflectionCube;
    }

    function initLight() {
        /*var ambientLight = new THREE.AmbientLight("#ffecb3");
        scene.add(ambientLight);

        var spotLight = new THREE.PointLight("#ffecb3");
        spotLight.position.set(2000, 2000, 2000);
        spotLight.castShadow = true;
        scene.add(spotLight);*/

        light = new THREE.DirectionalLight(0xffecb3, 0.8);
        light.position.set(2000, 2000, 2000);
        //告诉光需要开启阴影投射
        light.castShadow = true;
        scene.add(light);
    }

    function initModel() {
        // material loader
        let mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('obj/');
        mtlLoader.load('22.mtl', function(materials) {
            materials.preload();
            // model loader
            let objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('obj/');
            objLoader.load('22.obj', function(obj) {
                obj.traverse(function(child) {
                    if (child instanceof THREE.Mesh) {
                        child.material.side = THREE.DoubleSide;
                        //child.material.normalMap = texture;
                    }
                });
                obj.castShadow = true; //投影
                //mesh = obj; //如果注释掉，则不旋转
                scene.add(obj);
            });
        });

        //底部平面
        var planeGeometry = new THREE.PlaneGeometry(100000, 100000);
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.y = -1250;
        //告诉底部平面需要接收阴影
        plane.receiveShadow = true;
        scene.add(plane);
    }
    
    function initControls() {
        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true;
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        controls.dampingFactor = 1.0;
        //是否可以缩放
        controls.enableZoom = true;
        //是否自动旋转
        controls.autoRotate = false;
        //设置相机距离原点的最远距离
        controls.minDistance = 4000;
        //设置相机距离原点的最远距离
        controls.maxDistance = 50000;
        //是否开启右键拖拽
        controls.enablePan = true;
        //controls.minPolarAngle = Math.PI / 4;
        //controls.maxPolarAngle = Math.PI / 1.5;
    }

    function init() {
        initRender();
        initCamera();
        initScene();
        initLight();
        initModel();
        initControls();
        window.addEventListener( 'resize', onWindowResize, false );
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function animate() {
        requestAnimationFrame( animate );
        render();
    }

    function render() {
        renderer.render( scene, camera );
    }
</script>
</body>
</html>